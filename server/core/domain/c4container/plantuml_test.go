package c4container

import (
	"reflect"
	"testing"
)

func Test_compress(t *testing.T) {
	type args struct {
		v []byte
	}
	tests := []struct {
		name    string
		args    args
		want    []byte
		wantErr bool
	}{
		{
			name: "foo",
			args: args{
				v: []byte("foo"),
			},
			want:    []byte{75, 203, 207, 7, 0},
			wantErr: false,
		},
		{
			name: "foobar",
			args: args{
				v: []byte("foobar"),
			},
			want:    []byte{75, 203, 207, 79, 74, 44, 2, 0},
			wantErr: false,
		},
		{
			name: "@startuml",
			args: args{
				v: []byte(`@startuml`),
			},
			want:    []byte{115, 40, 46, 73, 44, 42, 41, 205, 205, 1, 0},
			wantErr: false,
		},
		{
			name: `foo
bar`,
			args: args{
				v: []byte(`foo
bar`),
			},
			want:    []byte{75, 203, 207, 231, 74, 74, 44, 2, 0},
			wantErr: false,
		},
		{
			name: "->",
			args: args{
				v: []byte(`->`),
			},
			want:    []byte{211, 181, 3, 0},
			wantErr: false,
		},
		{
			name: "a->b",
			args: args{
				v: []byte("a->b"),
			},
			want:    []byte{75, 212, 181, 75, 2, 0},
			wantErr: false,
		},
		{
			name: "a -> b",
			args: args{
				v: []byte("a -> b"),
			},
			want:    []byte{75, 84, 208, 181, 83, 72, 2, 0},
			wantErr: false,
		},
		{
			name: `@startuml
    a -> b
@enduml`,
			args: args{
				v: []byte(`@startuml
    a -> b
@enduml`),
			},
			want: []byte{
				115, 40, 46, 73, 44, 42, 41, 205, 205, 225, 82, 0, 130, 68, 5, 93, 59, 133, 36, 46, 135, 212, 188, 20,
				160, 16, 0,
			},
			wantErr: false,
		},
		{
			name: "unhappy path",
			args: args{
				v: []byte{0},
			},
			want:    nil,
			wantErr: true,
		},
	}
	for _, tt := range tests {
		t.Run(
			tt.name, func(t *testing.T) {
				got, err := compress(tt.args.v)
				if (err != nil) != tt.wantErr {
					t.Errorf("compress() error = %v, wantErr %v", err, tt.wantErr)
					return
				}
				if !reflect.DeepEqual(got, tt.want) {
					t.Errorf("compress() got = %v, want %v", got, tt.want)
				}
			},
		)
	}
}

func Test_encode6bit(t *testing.T) {
	type args struct {
		min, max, threshold byte
	}
	tests := []struct {
		name string
		args args
		want func(in byte, got byte) bool
	}{
		{
			name: "<10bite",
			args: args{0, 10, 48},
		},
		{
			name: "<36bite",
			args: args{10, 36, 65},
		},
		{
			name: "<62bite",
			args: args{36, 62, 97},
		},
		{
			name: "'-'",
			args: args{62, 62, '-'},
		},
		{
			name: "'_'",
			args: args{63, 63, '_'},
		},
		{
			name: "'?'",
			args: args{64, 64, '?'},
		},
	}
	t.Parallel()
	for _, tt := range tests {
		t.Run(
			tt.name, func(t *testing.T) {
				for i := tt.args.min; i < tt.args.max; i++ {
					got := encode6bit(i)
					want := tt.args.threshold + i - tt.args.min
					if got != want {
						t.Errorf("encode6bit(%v) unexpected result. got = %v, want = %v", i, got, want)
						return
					}
				}
			},
		)
	}

	// syntax signs

}

func Test_encode64(t *testing.T) {
	type args struct {
		e []byte
	}
	tests := []struct {
		name string
		args args
		want string
	}{
		{
			name: "len(e)==2",
			args: args{
				e: []byte{0, 0},
			},
			want: "0000",
		},
		{
			name: "len(e)==1",
			args: args{
				e: []byte{0},
			},
			want: "0000",
		},
		{
			name: "len(e)==3",
			args: args{
				e: []byte{0, 0, 0},
			},
			want: "0000",
		},
	}
	for _, tt := range tests {
		t.Run(
			tt.name, func(t *testing.T) {
				if got := encode64(tt.args.e); got != tt.want {
					t.Errorf("encode64() = %v, want %v", got, tt.want)
				}
			},
		)
	}
}

func Test_marshal(t *testing.T) {
	type args struct {
		c *c4ContainersGraph
	}
	tests := []struct {
		name    string
		args    args
		want    []byte
		wantErr bool
	}{
		{
			name: "single node",
			args: args{
				c: &c4ContainersGraph{
					Containers: []*container{{ID: "0"}},
				},
			},
			want: []byte(`@startuml
!include https://raw.githubusercontent.com/plantuml-stdlib/C4-PlantUML/master/C4_Container.puml
footer "generated by diagramastext.dev - %date('yyyy-MM-dd')"
Container(0, "0")
@enduml`),
			wantErr: false,
		},
	}
	for _, tt := range tests {
		t.Run(
			tt.name, func(t *testing.T) {
				got, err := marshal(tt.args.c)
				if (err != nil) != tt.wantErr {
					t.Errorf("marshal() error = %v, wantErr %v", err, tt.wantErr)
					return
				}
				if !reflect.DeepEqual(got, tt.want) {
					t.Errorf("marshal() got = %v, want %v", got, tt.want)
				}
			},
		)
	}
}
